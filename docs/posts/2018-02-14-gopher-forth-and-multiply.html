<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blog</title>
  <link rel="stylesheet" href="/blogger/css/blog.css">

</head>
<body>
<div class="header">
  <div class="container">
    <a href="/blogger">des.io</a>
  </div>
</div>

<div class="content">
  <div class="container">
    <h1>Gopher Forth and Multiply</h1>

<p>Suppose you are tasked with implementing multiplication for two non-negative integers, that is:</p>

<p>\[ M(a,n) = a \times n  \text{ where } a,n \in \{0,1,2,&hellip;\} \]</p>

<p>(todo: explain simple case where multiplying by powers of 2 as a starting point)
(todo: discuss legal operations)</p>

<p>At risk of perpetuating <a href="https://www.maa.org/external_archive/devlin/devlin_06_08.html">multiplication as repeated addition</a> we can use the fact that repeated addition for the natural numbers yields the same result as multiplication. Then we can express multiplication as recursive addition, by first defining the base case for \(n = 0\) and then for the arbitrary case where \(n &gt; 0\):</p>

<p>\[
M(a,n) =
\begin{cases}
  0          &amp; \text{if } n = 0 \\
  (n-1)a + a &amp; \text{if } n &gt; 0
\end{cases} \]</p>

<p>Which although might seem obviously correct, we can prove it via induction:</p>

<p>\[ \text{base case: }  M(a,0) = a \times 0 = 0 \]</p>

<p>\[ \text{Suppose true for arbitrary n:} \]</p>

<p>\[ \begin{aligned}
M(a,n+1) &amp;= ((n+1)-1)a + a \\
         &amp;= ((n-0)a + a \\
\end{aligned} \]</p>
<pre class="chroma"><span class="c1">// multiply.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nx">Multiply0</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;operand &lt; 0&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">Multiply0</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">a</span>
<span class="p">}</span>
</pre>
<p>To get an idea of how well we might be doing, we can benchmark our implementation and compare it to the native mulitplication operator:</p>
<pre class="chroma"><span class="c1">// multiply.go
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Multiply</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nx">MultiplyNative</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;operand &lt; 0&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">n</span>
<span class="p">}</span>
</pre>
<p>Now we can create generic test to benchmark for small and large operands:</p>
<pre class="chroma"><span class="c1">// multiply_test.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nx">benchmarkMultiply</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="nx">a</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">multiply</span> <span class="nx">Multiply</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">multiply</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
<p>On my mac I get the following results:</p>

<table>
<thead>
<tr>
<th>Method</th>
<th>\(a\)</th>
<th>\(n\)</th>
<th>performance</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>native</code></td>
<td>2</td>
<td>16</td>
<td>2.80 ns/op</td>
</tr>

<tr>
<td><code>multiply0</code></td>
<td>2</td>
<td>16</td>
<td>9.00 ns/op</td>
</tr>

<tr>
<td><code>native</code></td>
<td>19,998</td>
<td>12,234</td>
<td>2.46 ns/op</td>
</tr>

<tr>
<td><code>multiply0</code></td>
<td>19,998</td>
<td>12,234</td>
<td>4,143 ns/op</td>
</tr>
</tbody>
</table>
<p>Observe the number of operations for our naive first implementation for the large numbers. So let&rsquo;s turn back to our symbolic representation of the problem to see how it behaves for case \(n = 4\):</p>

<div katex>
\[ \begin{aligned}
M(a,4) &= (4-1)a+a \\
       &= ((3-1)a+a)+a \\
       &= (((2-1)a+a)+a)+a \\
       &= ((((1-1)a+a)+a)+a)+a \\
       &= (((0+a)+a)+a)+a \\
       &= ((a+a)+a)+a \\
       &= (a+a)+(a+a) (associative law of addition) \\ 
       &= 2(a+a) \\
\end{aligned} \]
</div>

<p>This means that we only need to compute \(a+a\) once and then reuse it. We can generalize this as:</p>

<p>$$ M(a,n) = M(a+a, \frac{n}{2}) $$</p>

<p>Notice that calculating\(a+a\)) and \(\frac{n}{2}\) are as simple as a bitwise shift to the left and right respectively if \(n\) is an even number. In fact in the case where \(n\) is a power of two, that repeatedly dividing in half would eventually reduce the second argument to \(1\) which we could use as our inductive base case and we could construct the recursive algorithm as:</p>
<pre class="chroma"><span class="c1">// multiply.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nx">Multiply1</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;operand &lt; 0&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">Multiply1</span><span class="p">(</span><span class="nx">a</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="nx">n</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</pre>
<p>This is a big improvement in terms of operations, because in each successive iteration \(n\) decreased by a factor of 2 and we are only performing constant time operations in our function we have gone from a worst case scenario of \(O(n)\) to \(O(\log{n})\).</p>

<p>However our algorithm assumes that we can divide \(n\) by a factor of two cleanly at every iteration, that is we assume that \(n\)) is a power of 2. If we invoked our new method with \(n=28\) for example we will get an incorrect result:</p>

<p>(todo: &ldquo;// Run this program in the Go Playground.&rdquo; link)</p>
<pre class="chroma"><span class="nx">fmt</span><span class="p">.</span><span class="nx">PrintLn</span><span class="p">(</span><span class="nx">Multiply1</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">28</span><span class="p">)</span><span class="p">)</span> <span class="c1">// 32
</span><span class="c1"></span></pre>
<p>We can modify our function to perform an additional check for the case where \(n\) is odd and doing any additional calculation for that case.</p>

<p>To figure out what extra work is needed, we can observe that for the case where \(n\) is odd our bitwise operation effectively ignores the last bit, thus:</p>

<p>\[
n \gg 1 =
\begin{cases}
  \frac{n}{2} &amp; \text{if } n \text{ is even} \\
  \frac{n-1}{2} &amp; \text{if } n \text{ is odd}
\end{cases} \]</p>

<p>So we can calculate the error  in the case where \(n\) is odd as:</p>

<p>\[ \begin{aligned}
\text{error} &amp;= \text{correct} - \text{result} \\
              &amp;= M(a,n) - M(a+a,n \gg 1) \\
              &amp;= M(a,n) - M(2a,\frac{n-1}{2}) \\
              &amp;= an - 2a\big(\frac{n-1}{2}\big) \\
              &amp;= an - a(n-1) \\
              &amp;= an - an+a \\
              &amp;= a
\end{aligned} \]</p>

<p>So we can see that all we need to do to adjust our algorith is to add the error \(a\) in the case where \(n\) is negative. We can determine if \(n\) is negative by checking if its least significant bit is a \(1\) via a bitmask (todo: illustrate the bitmask), and result in the following corrected implementation.</p>
<pre class="chroma"><span class="c1">// multiply.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nx">Multiply1</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;operand &lt; 0&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span>
  <span class="p">}</span>

  <span class="nx">result</span> <span class="o">:=</span> <span class="nx">Multiply1</span><span class="p">(</span><span class="nx">a</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="nx">n</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span>

  <span class="k">if</span> <span class="nx">n</span><span class="o">&amp;</span><span class="mh">0x1</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="c1">// account for error of &#34;a&#34; 
</span><span class="c1"></span>    <span class="c1">// for case where &#34;n&#34; is odd
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">result</span> <span class="o">+</span> <span class="nx">a</span> 
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</pre>
<p>On my mac I get the following results: (todo: split into two tables with captions OR use bar chart)</p>

<table>
<thead>
<tr>
<th>Method</th>
<th>\(a\)</th>
<th>\(n\)</th>
<th>performance</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>native</code></td>
<td>2</td>
<td>16</td>
<td>2.80 ns/op</td>
</tr>

<tr>
<td><code>multiply0</code></td>
<td>2</td>
<td>16</td>
<td>53.7 ns/op</td>
</tr>

<tr>
<td><code>multiply1</code></td>
<td>2</td>
<td>16</td>
<td>15.1 ns/op</td>
</tr>

<tr>
<td><code>native</code></td>
<td>19,998</td>
<td>12,234</td>
<td>2.46 ns/op</td>
</tr>

<tr>
<td><code>multiply0</code></td>
<td>19,998</td>
<td>12,234</td>
<td>4,143 ns/op</td>
</tr>

<tr>
<td><code>multiply1</code></td>
<td>19,998</td>
<td>12,234</td>
<td>46.3 ns/op</td>
</tr>
</tbody>
</table>
<p>Which is almost 2 orders of magnitude better than our first naive algorithm in the case where our inputs are even a little large! However we are still not even close to matching the native multiplication implementation in the language.</p>

  </div>
</div>

<div class="footer">
  <div class="container">
    <a href="https://github.com/desicochrane">github</a>
  </div>
</div>

<script src="/blogger/js/blog.js"></script>
</body>
</html>
