<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blog</title>
  <link rel="stylesheet" href="/blogger/css/blog.css">

</head>
<body>
<div class="header">
  <div class="container">
    <a href="/blogger">des.io</a>
  </div>
</div>

<div class="content">
  <div class="container">
    <h1>Gopher Forth and Binary Multiply</h1>

<h3>The problem</h3>

<p>Suppose we are tasked with implementing a function <code>Multiply</code> which takes two positive integers \(a\), \(n\) and outputs their product:</p>

<p>$$ \text{Multiply} : (a,n) \to a \times n \text{ where } a,n \in \{1,2,3,\ldots \} $$</p>

<p>We are not allowed to use the native product operator <code>*</code> in our solution, however bitwise operations, addition and subtraction are permitted.</p>

<p>Because we will be comparing several different implementations, it is convenient to first define an interface for our solutions to adhere to:</p>
<pre class="chroma"><span class="c1">// multiply.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">multiply</span>

<span class="kd">type</span> <span class="nx">Multiply</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
</pre>
<blockquote>
<p>For the remainder of this article we assume \(a\) and \(n\) to be strictly positive integers.</p>
</blockquote>

<h3>Multiplication as repeated addition</h3>

<p>At risk of perpetuating <a href="https://www.maa.org/external_archive/devlin/devlin_06_08.html">multiplication as repeated addition</a>, we can take advantage of the fact that repeated addition for the natural numbers yields the same result as multiplication, that is:</p>

<p>$$ \text{Multiply}(a,n) = a \times n = \sum_{1}^n a  $$</p>

<p>When we translate this to golang we get:</p>
<pre class="chroma"><span class="c1">// multiply.go
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Multiply</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nx">RepeatedAddition</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">product</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">product</span> <span class="o">+=</span> <span class="nx">a</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">product</span>
<span class="p">}</span>
</pre>
<h3>Benchmarking</h3>

<p>To get a feeling of how well our solution performs we can use golang&rsquo;s benchmarking tool to compare our solution with the native product operator:</p>
<pre class="chroma"><span class="c1">// multiply.go
</span><span class="c1"></span>
<span class="c1">// the native operate to compare our solutions against 
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">NativeProduct</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">n</span>
<span class="p">}</span>
</pre><pre class="chroma"><span class="c1">// multiply_test.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">multiply</span>

<span class="c1">// helper function (lowercase first letter) to 
</span><span class="c1"></span><span class="c1">// benchmark any implementation of &#34;Multiply&#34;
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">benchmarkMultiply</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="nx">a</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">multiply</span> <span class="nx">Multiply</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">multiply</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">BenchmarkNativeProduct</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">benchmarkMultiply</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="nx">NativeProduct</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">BenchmarkRepeatedAddition</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">benchmarkMultiply</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="nx">RepeatedAddition</span><span class="p">)</span>
<span class="p">}</span>
</pre>
<p>I ran this on my mac for various inputs for \( (a,n) \) and I get:</p>

<table>
<thead>
<tr>
<th>\( (a,n) \)</th>
<th><code>NativeProduct</code></th>
<th><code>RepeatedAddition</code></th>
</tr>
</thead>

<tbody>
<tr>
<td>\( (17,28) \)</td>
<td>2.4 ns/op</td>
<td>13.0 ns/op</td>
</tr>

<tr>
<td>\( (19998,12234) \)</td>
<td>2.4 ns/op</td>
<td>4,182 ns/op</td>
</tr>
</tbody>
</table>
<p>We can see that our solution performs poorly compared to the native product operator and does not scale at all for larger inputs. I also tried much larger inputs, but I lost my patience well before <code>RepeatedAddition</code> finished its computation.</p>

<p>It seems we need to be more clever in our approach.</p>

<h3>Shifting to double and halve</h3>

<p>We tried addition, but now let&rsquo;s explore bitwise shifts. We can use the fact that a performing a bitwise left-shift on a number \(k\) times is the same as multiplying by it by two \(k\) times. That is:</p>

<p>$$ a \times 2^k \equiv a \ll k \text{ where } k \in \{0,1,2,\ldots\} $$</p>

<p>Then for the special case where \(n\) is a natural power of 2 we can shift \(a\) to the left \(\log_2{n}\) times to arrive at a correct solution:</p>

<p>$$ \text{Multiply} : (a,n) \to a \ll log_2{n} \text{ where } n \in \{2^0,2^1,2^2,\ldots \} $$</p>

<p>However this requires performing a logarithm operation to compute \(\log_2{n}\), which is not an operation we are allowed to use in our solution. To avoid logarithms we can turn to the properties of exponents and express our function recursively:</p>

<p>\[ \begin{aligned}
\text{Multiply}(a, 2^k) &amp;= a \times 2^k \\
                         &amp;= a \times (2^1 \times 2^{k-1}) \\
                         &amp;= (a \times 2^1) \times 2^{k-1} \\
                         &amp;= \text{Multiply}(a \times 2^1, 2^{k-1}) \\
                         &amp;= \text{Multiply}(a \times 2^2, 2^{k-2}) \\
                         &amp;= \text{Multiply}(a \times 2^3, 2^{k-3}) \\
                         &amp; \ldots \\
                         &amp;= \text{Multiply}(a \times 2^k, 2^0)
\end{aligned} \]</p>

<p>Recursively applying the above result means we are doubling \(a\) and halving \(n\) at each recursive call until eventually reaching the trivial case where \(n=2^0 = 1\). Since doubling and halving can be computed by left and right shifts we get the following recursive function definition:</p>

<p>\[
\text{Multiply}(a,n) =
\begin{cases}
  a                             &amp; \text{if } n = 1 \\
  \text{Multiply}(a\ll1,n\gg1) &amp; \text{if } n &gt; 1 \\
\end{cases}
\text{ where } n \in \{2^0,2^1,2^2,\ldots\}
\]</p>

<p>Implementing this in golang, we get:</p>
<pre class="chroma"><span class="c1">// multiply.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nx">RecursiveDoubleHalf</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">RecursiveDoubleHalf</span><span class="p">(</span><span class="nx">a</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="nx">n</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</pre>
<h3>Accounting for our error</h3>

<blockquote>
<p>todo</p>
</blockquote>

<h3>Understanding what&rsquo;s happening</h3>

<blockquote>
<p>todo</p>
</blockquote>

<h3>Tail recursion</h3>

<blockquote>
<p>todo</p>
</blockquote>

<h3>Fine Tuning</h3>

<blockquote>
<p>todo</p>
</blockquote>

<h3>Summary</h3>

<blockquote>
<p>todo</p>
</blockquote>

  </div>
</div>

<div class="footer">
  <div class="container">
    <a href="https://github.com/desicochrane">github</a>
  </div>
</div>

<script src="/blogger/js/blog.js"></script>
</body>
</html>
