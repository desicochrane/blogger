---
title: [wip] GCD
date: 01-Jan-2018
---

gcd is an essential operation for computing inverses modulo: find an integer k such that n \\(ak \equiv 1 \bmod n\\)

> problem simplify fraction?

Interface:
```go
// gcd.go
package gcd

type GCD func(a int, b int) int
```

```go
// gcd.go

func GCDNaive(a int, b int) int {
  if b > a {
  		a, b = b, a
  	}
  
  	if b == 0 {
  		return a
  	}
  
  	for i := b; i > 0; i-- {
  		if b%i == 0 && a%i == 0 {
  			return i
  		}
  	}
  
  	return 1
}
```
Note: ^ fails for when one is zero. explain why both cannot be zero (why is it undefined)

analyse: worst case, will be 2*minimum(a,b) divisions
> todo: use shortest side of rectangle for intuition for difference algorithm


> euclids lemma: \\(d\\) divides \\(a\\) and \\(b\\) if and only if \\(d\\) divides \\(a-b\\) and \\(b\\)

> algebraic proof is trivial

> another "visual" 2 divides 10 and 6, hence 2 divides 4. can show with the two rectangles as an intuition.

### Diff

Need to prove: gcd(a,b) = gcd(b, a - b)

```go
func GCDDifference(a int, b int) int {
	if b > a {
		a, b = b, a
	}

	if b == 0 {
		return a
	}

	return GCDDifference(b, a-b)
}
```

### Mod

(are we cheating by using the built in mod operator? todo: implement mod)

```go
func GCDMod(a int, b int) int {
	if b > a {
		a, b = b, a
	}

	if b == 0 {
		return a
	}

	return GCDMod(b, a%b)
}
```

can show the tail-recursive can be replaced with loop!

> todo: prove gcd mod is fast (halves every n)

### need to show:
gcd(a, b) = gcd(a, a mod b)

### can show:
if 
  d|a and d|b 
then
  d|(r = a mod b)

proof numerically:
if d|a then a = d*m, where m ∈ Int
if d|b then b = d*n, where n ∈ Int

then by definition:
a = b*k + r, where k ∈ Int
r = a - b*k
  = (d*m) - (d*n)*k
  = d(m - n*k)

since m, n, k ∈ Int, d|r

 maybe can prove by contradiction? if there was a greater number that divides r? then it would be greater than the gcd(a,b) 

### Extended


