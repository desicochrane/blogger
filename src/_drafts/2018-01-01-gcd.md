---
title: [wip] GCD
date: 01-Jan-2018
---

prerequisite: division article + tail recursion articles.

gcd is an essential operation for computing inverses modulo: find an integer k such that n \\(ak \equiv 1 \bmod n\\)

> problem simplify fraction?

Interface:
```go
// gcd.go
package gcd

type GCD func(a int, b int) int
```

```go
// gcd.go

func GCDNaive(a int, b int) int {
  if b > a {
  		a, b = b, a
  	}
  
  	if b == 0 {
  		return a
  	}
  
  	for i := b; i > 0; i-- {
  		if b%i == 0 && a%i == 0 {
  			return i
  		}
  	}
  
  	return 1
}
```
Note: ^ fails for when one is zero. explain why both cannot be zero (why is it undefined)

analyse: worst case, will be 2*minimum(a,b) divisions, explain laptop can do 10^9 operations per second how long this will take.
> todo: use shortest side of rectangle for intuition for difference algorithm


> euclids lemma: \\(d\\) divides \\(a\\) and \\(b\\) if and only if \\(d\\) divides \\(a-b\\) and \\(b\\)

> algebraic proof is trivial

> another "visual" 2 divides 10 and 6, hence 2 divides 4. can show with the two rectangles as an intuition.

### Diff

> Need to prove: gcd(a,b) = gcd(b, a - b)


```go
func GCDDifference(a int, b int) int {
	if b > a {
		a, b = b, a
	}

	if b == 0 {
		return a
	}

	return GCDDifference(b, a-b)
}
```

> Need to prove this terminates (not the necessarily the case for greatest common **measure**!) 

### Mod

(are we cheating by using the built in mod operator? todo: implement mod)

```go
func GCDMod(a int, b int) int {
	if b > a {
		a, b = b, a
	}

	if b == 0 {
		return a
	}

	return GCDMod(b, a%b)
}
```

can show the tail-recursive can be replaced with loop!

> todo: prove gcd mod is fast (halves every n), number of iterations is \\(\log_2{a} + \log_2{b} \\)
Let \\( a \ge b > 0 \\). Then \\( (a \bmod b) < \frac{a}{2} \\)  tip: case where b < a/2 or where b > a/2


### need to show:
gcd(a, b) = gcd(a, a mod b)

### can show:
if 
  d|a and d|b 
then
  d|(r = a mod b)

proof numerically:
if d|a then a = d*m, where m ∈ Int
if d|b then b = d*n, where n ∈ Int

then by definition:
a = b*k + r, where k ∈ Int
r = a - b*k
  = (d*m) - (d*n)*k
  = d(m - n*k)

since m, n, k ∈ Int, d|r

 maybe can prove by contradiction? if there was a greater number that divides r? then it would be greater than the gcd(a,b) 

### Extended

Suppose someone computed gcd of a and b. how can they convince you they have actually found the gcd?

they can present s and t. you can verify that sa + tb = d, and verify that d divides a and b. (todo: see if this is faster than just computing d yourself!)

Can prove why, that if \\( d = sa + tb \\) and \\(d \mid a \\) and \\(d \mid b) then d must be the gcd (algebraically and intuitively using shapes). 

> Lemma: if d|a and d|b and d=ax+by then d=gcd(a,b)
since d does divide a and b, we at least know it is a common divisor. since no divisor can be greater than the greatest common divisor (tautologies yo!) d must either be less than the gcd or equal to it: then d <= gcd(a,b)
> need to prove that any divisor of a and b is also a divisor of any linear combination of a and b.
> need to then show that d is a linear combination of a and b.
> then can show that the gcd must divide d so it cannot be bigger than d, which implies that gcd(a,b) <= d
> therefore, d is EQUAL to gcd. 

But what if there are NO s and t? But how to prove that such an s and t MUST exist? <bezouts lemma yo...>

can "prove" mechanically by solving for gcd and working backwards, and then showing that process would work for arbitrary a,b?
can "prove" by assuming true showing gcd(a,b) = gcd(b,a%b) therefore d = sa + tb = pb + q(a%b), then prove by induction?


```go
func XGCD(a int, b int) (int, int) {
  if b == 0 {
    return 1, 0
  }

  s, t := XGCD(b, a%b)
  return t, s - t*(a/b)
}
```

```go
func WikipediaXGCD(a int, b int) (int, int) {
  s, oldS, t, oldT, r, oldR := 0, 1, 1, 0, b, a
  for r != 0 {
    q := oldR / r
    oldR, r = r, oldR-q*r
    oldS, s = s, oldS-q*s
    oldT, t = t, oldT-q*t
  }
  return oldS, oldT
}
```

\\(d = \\text{gcd}(a,b)\\) is greatest common divisor of two integers \\(a\\) and \\(b\\)

$$ d = \\text{gcd}(a,b) $$

$$ d = \\text{gcd}(24,16) = 8$$

Given two integers a and b find the integers s and t such that \\( d = s \times a + t \times b \\)

$$ s, t = \text{xgcd}(a,b) $$

$$ s, t = \text{xgcd}(24,16) = 1, -1 $$

$$ 8 = 1 \times 24 + -1 \times 16 $$

```go
func XGCD(a int, b int) (int, int) {
	if b == 0 {
		return 1, 0
	}

	s, t := XGCD(b, a%b)
	return t, s - t*(a/b)
}
```

\\[ \\begin{aligned}
T\Big(\lfloor \frac{a}{b} \rfloor, \begin{bmatrix} s \\\ t \end{bmatrix}\Big) &= \begin{bmatrix} t \\\ s - t \times \lfloor \frac{a}{b} \rfloor \end{bmatrix} \\\\
&= \begin{bmatrix} 0 & 1 \\\ 1 & \lfloor -\frac{a}{b} \rfloor \end{bmatrix} \times \begin{bmatrix} s \\\ t \end{bmatrix} \\\\
&= \mathbf{A}\_{(a,b)} \times \begin{bmatrix} s \\\ t \end{bmatrix} \text{ where } \mathbf{A}\_{(a,b)} = \begin{bmatrix} 0 & 1 \\\ 1 & \lfloor -\frac{a}{b} \rfloor \end{bmatrix}
\\end{aligned} \\]


\\[ \\begin{aligned}
\\text{xgcd}\Big(\begin{bmatrix} 24 \\\ 16 \end{bmatrix}\Big) &= \mathbf{A}\_{(24,16)} \times \\text{xgcd}\Big(\begin{bmatrix} 16 \\\ 8 \end{bmatrix}\Big) \\\\
&= \mathbf{A}\_{(24,16)} \times \mathbf{A}\_{(16,8)} \times \\text{xgcd}\Big(\begin{bmatrix} 8 \\\ 0 \end{bmatrix}\Big) \\\\
&= \mathbf{A}\_{(24,16)} \times \mathbf{A}\_{(16,8)} \times \begin{bmatrix} 1 \\\ 0 \end{bmatrix} \\\\
&= \mathbf{A}\_{(24,16)} \times \begin{bmatrix} 0 \\\ 1 \end{bmatrix} \\\\
&= \begin{bmatrix} 1 \\\ -1 \end{bmatrix} \\\\
\\end{aligned} \\]

\\[ \\begin{aligned}
\\text{xgcd}\Big(\begin{bmatrix} 24 \\\ 16 \end{bmatrix}\Big) &= \\text{xgcd}^{\prime}\Big(\mathbf{A}\_{(24,16)}, \begin{bmatrix} 16 \\\ 8 \end{bmatrix}\Big) \\\\
&= \\text{xgcd}^{\prime}\Big(\mathbf{A}\_{(24,16)} \times \mathbf{A}\_{(16,8)}, \begin{bmatrix} 8 \\\ 0 \end{bmatrix}\Big) \\\\
&= \begin{bmatrix} 1 & -2 \\\ -1 & 3 \end{bmatrix} \times \begin{bmatrix} 1 \\\ 0 \end{bmatrix} \\\\
&= \begin{bmatrix} 1 \\\ -1 \end{bmatrix}
\\end{aligned} \\]

\\[
\text{xgcd}\Big(\begin{bmatrix} a \\\ b \end{bmatrix}\Big) = \\text{xgcd}^{\prime}\Big(I, \begin{bmatrix} a \\\ b \end{bmatrix}\Big)
\\]


\\[
\\text{xgcd}^{\prime}\Big(\mathbf{A}, \begin{bmatrix} a \\\ b \end{bmatrix} \Big) =
\\begin{cases}
  \mathbf{A} \times \begin{bmatrix} a \\\ b \end{bmatrix}    & \\text{if } b = 0 \\\\
  \\text{xgcd}^{\prime}\Big(\mathbf{A} \times \mathbf{A}\_{(a,b)}, \begin{bmatrix} b \\\ a \bmod b \end{bmatrix} \Big) & \\text{if } b \ne 0 \\\\
\\end{cases}
\\]

```go
func XGCD(a int, b int) (int, int) {
  m1, m2, m3, m4 := 1, 0, 0, 1

  for b != 0 {
    q := a / b
    m1, m2, m3, m4, a, b = m2, m1-q*m2, m4, m3-q*m4, b, a%b
  }
  return m1, m3
}
```
